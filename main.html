<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trailblazer â€” Daily</title>
<style>
  :root{ --tile:60px; }
  body {
    font-family: Inter, system-ui, sans-serif;
    display:flex; flex-direction:column; align-items:center;
    gap:10px; padding:20px; background:#f3f4f6; color:#111827;
  }
  h1{font-size:18px;margin:0}
  #meta { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  #info { font-size:14px; color:#374151; }
  #boardContainer { position:relative; background:#000; }
  #board { display:grid; gap:0; }
  .tile {
    width:var(--tile); height:var(--tile);
    border-radius:6px; transition: transform .12s ease;
  }
  .tile:hover { transform: scale(1.04); }
  #pathCanvas { position:absolute; left:0; top:0; z-index:2; pointer-events:none; }
  #status { font-size:15px; margin-top:6px; }
  button {
    padding:8px 12px; background:#0f172a; color:white;
    border:none; border-radius:8px; cursor:pointer;
  }
  button:disabled{opacity:.5; cursor:default}
  .note { font-size:13px; color:#6b7280; max-width:400px; text-align:center; }
  #share { margin-left:8px; background:#0369a1; }
</style>
</head>
<body>
  <h1>Trailblazer â€” Daily</h1>

  <div id="meta">
    <div id="info">
      Par (minimal color changes): <strong id="parDisplay">â€“</strong>
    </div>
  </div>

  <div id="status">
    Color changes: <span id="cc">0</span> â€¢ Time: <span id="t">0.0</span>s
  </div>

  <div id="boardContainer">
    <div id="board"></div>
    <canvas id="pathCanvas"></canvas>
  </div>

  <div style="display:flex;gap:8px;align-items:center;">
    <button id="restart">Restart</button>
    <button id="showSolution" style="display:none">Show Solution</button>
    <button id="share" style="display:none">Share</button>
  </div>

  <div class="note">
    You must match the minimal color changes (Par) to win.  
    Restart clears your attempt but timer keeps running.  
    Once solved, the dayâ€™s puzzle is locked.
  </div>

<script>
/* --- configuration --- */
const baseColors=["#ef4444","#f97316","#facc15","#10b981","#06b6d4","#3b82f6","#7c3aed","#ec4899"];
const tileSize=60;document.documentElement.style.setProperty('--tile',tileSize+'px');

/* state */
let N=6,board=[],visited=new Set(),playerPath=[],parColorChanges=0;
let colorChangesUsed=0,activeColor=null,timeSeconds=0,isTiming=false,timerId=null;
let lastCell=null,solutionData=null,gameOver=false;

/* DOM */
const boardDiv=document.getElementById("board");
const pathCanvas=document.getElementById("pathCanvas");
const ctx=pathCanvas.getContext("2d");
const restartBtn=document.getElementById("restart");
const showSolutionBtn=document.getElementById("showSolution");
const shareBtn=document.getElementById("share");

restartBtn.addEventListener("click",restartAttempt);
showSolutionBtn.addEventListener("click",revealSolution);
shareBtn.addEventListener("click",shareResult);

/* helpers */
function ipair(r,c){return{r,c};}
function coordKey(c){return`${c.r}_${c.c}`;}
function isAdjacent(a,b){return Math.abs(a.r-b.r)+Math.abs(a.c-b.c)===1;}

/* generate daily Hamiltonian snake path */
function generateBoard(){
  const today=new Date();
  const weekday=today.getDay(); // 0 = Sunday
  const path=[];
  for(let r=0;r<N;r++){
    if(r%2===0){for(let c=0;c<N;c++)path.push(ipair(r,c));}
    else{for(let c=N-1;c>=0;c--)path.push(ipair(r,c));}
  }
  // difficulty scaling: easy=3 segments, hard=10
  const segs=Math.min(3+weekday,10);
  parColorChanges=segs-1;
  let segLen=Math.floor(path.length/segs);
  board=Array(N).fill(0).map(()=>Array(N).fill(0));
  let color=0,idx=0;
  for(let sIdx=0;sIdx<segs;sIdx++){
    for(let k=0;k<segLen && idx<path.length;k++,idx++){
      let {r,c}=path[idx];board[r][c]=color;
    }
    color=(color+1)%baseColors.length;
  }
  while(idx<path.length){let {r,c}=path[idx++];board[r][c]=color;}
  solutionData={path,par:parColorChanges};
}

function renderBoard(){
  boardDiv.style.gridTemplateColumns=`repeat(${N},${tileSize}px)`;
  boardDiv.style.width=`${N*tileSize}px`;boardDiv.style.height=`${N*tileSize}px`;
  pathCanvas.width=N*tileSize;pathCanvas.height=N*tileSize;
  boardDiv.innerHTML='';
  for(let r=0;r<N;r++){for(let c=0;c<N;c++){const el=document.createElement("div");
    el.className="tile";el.style.background=baseColors[board[r][c]];
    el.dataset.r=r;el.dataset.c=c;
    el.addEventListener("pointerdown",tileClick);
    el.addEventListener("pointerover",tileHover);
    boardDiv.appendChild(el);}}
}

function startGame(){generateBoard();renderBoard();
  visited.clear();playerPath=[];colorChangesUsed=0;activeColor=null;lastCell=null;timeSeconds=0;gameOver=false;
  document.getElementById("cc").textContent="0";document.getElementById("t").textContent="0.0";
  document.getElementById("parDisplay").textContent=parColorChanges;drawPath();}

/* timer */
function startTimer(){if(isTiming)return;isTiming=true;timerId=setInterval(()=>{timeSeconds+=0.1;document.getElementById("t").textContent=timeSeconds.toFixed(1);},100);}
function stopTimer(){if(timerId)clearInterval(timerId);timerId=null;isTiming=false;}

/* path handling */
function tileClick(e){if(gameOver)return;
  const r=parseInt(e.currentTarget.dataset.r),c=parseInt(e.currentTarget.dataset.c);const cell={r,c};
  if(playerPath.length===0){playerPath.push(cell);visited.add(coordKey(cell));activeColor=board[r][c];lastCell=cell;startTimer();drawPath();}
  else tryExtend(cell);
}
function tileHover(e){if(e.buttons!==1||gameOver)return;
  const r=parseInt(e.currentTarget.dataset.r),c=parseInt(e.currentTarget.dataset.c);tryExtend({r,c});}
function tryExtend(cell){
  if(!isAdjacent(lastCell,cell)||visited.has(coordKey(cell)))return;
  const color=board[cell.r][cell.c];if(color!==activeColor){colorChangesUsed++;activeColor=color;}
  playerPath.push(cell);visited.add(coordKey(cell));lastCell=cell;drawPath();
  document.getElementById("cc").textContent=colorChangesUsed;checkComplete();}
function drawPath(){ctx.clearRect(0,0,pathCanvas.width,pathCanvas.height);
  if(playerPath.length<1)return;ctx.lineWidth=6;ctx.strokeStyle="white";ctx.lineCap="round";ctx.beginPath();
  playerPath.forEach((p,i)=>{let x=p.c*tileSize+tileSize/2,y=p.r*tileSize+tileSize/2;if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);});ctx.stroke();}

/* check win */
function checkComplete(){
  if(visited.size===N*N){
    stopTimer();gameOver=true;restartBtn.disabled=true;
    if(colorChangesUsed===parColorChanges){
      alert(`ðŸŽ‰ Perfect! Solved in ${timeSeconds.toFixed(1)}s with exactly ${parColorChanges} changes.`);
      shareBtn.style.display="inline-block";
    }else{
      alert(`All tiles covered, but you used ${colorChangesUsed}. Par is ${parColorChanges}.`);
      showSolutionBtn.style.display="inline-block";
    }
  }
}

/* restart attempt: clears path but timer continues */
function restartAttempt(){if(gameOver)return;
  visited.clear();playerPath=[];colorChangesUsed=0;activeColor=null;lastCell=null;
  document.getElementById("cc").textContent="0";drawPath();}

/* reveal solution */
function revealSolution(){
  ctx.clearRect(0,0,pathCanvas.width,pathCanvas.height);ctx.lineWidth=6;ctx.strokeStyle="#fbbf24";ctx.beginPath();
  solutionData.path.forEach((p,i)=>{let x=p.c*tileSize+tileSize/2,y=p.r*tileSize+tileSize/2;if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);});
  ctx.stroke();alert(`Minimal color changes: ${solutionData.par}`);}

/* share */
function shareResult(){const msg=`Trailblazer â€” Par ${parColorChanges} âœ“ â€” Time ${timeSeconds.toFixed(1)}s`;navigator.clipboard.writeText(msg).then(()=>alert("Copied to clipboard!"));}
startGame();
</script>
</body>
</html>

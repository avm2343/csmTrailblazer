<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trailblazer Daily Puzzle</title>
<style>
body {
  font-family: sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 20px;
  background: #f5f5f5;
}
#modeSelect { margin-bottom: 10px; }
#timer { margin-top: 10px; font-size: 18px; }
#boardContainer {
  position: relative;
  display: inline-block;
}
#board {
  display: grid;
  gap: 0px;
  background-color: black;
}
.tile {
  width: 60px;
  height: 60px;
  border-radius: 4px;
  cursor: pointer;
  transition: transform 0.2s ease;
  box-sizing: border-box;
}
.tile:hover { transform: scale(1.05); }
#pathCanvas {
  position: absolute;
  left: 0;
  top: 0;
  pointer-events: none; /* Allow clicks through canvas */
  z-index: 1;
}
#resetBtn, #showSolutionBtn {
  margin-top: 10px;
  padding: 6px 12px;
  border-radius: 6px;
  border: none;
  background-color: #457b9d;
  color: white;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s ease;
}
#resetBtn:hover, #showSolutionBtn:hover { background-color: #1d3557; }
</style>
</head>
<body>

<h2>Trailblazer Daily Puzzle</h2>
<div id="modeSelect">
  Mode:
  <select id="mode">
    <option value="color">Color Changes</option>
    <option value="time">Timed</option>
  </select>
</div>

<div id="timer">Color Changes: 0 | Time: 0.0s | Par: 0</div>
<div id="boardContainer">
  <div id="board"></div>
  <canvas id="pathCanvas"></canvas>
</div>
<button id="resetBtn">Restart Puzzle</button>

<script>
let N = 5;
let board = [];
let path = [];
let visited = new Set();
let colorChanges = 0;
let parColorChanges = 0;
let timer = 0;
let intervalId = null;
let activeColor = null;
let gameMode = 'color';
let solutionButtonCreated = false;
let lastCell = null;
const tileSize = 60;

const colors = ["#e63946","#f1faee","#a8dadc","#457b9d","#1d3557"];
const boardDiv = document.getElementById('board');
const boardContainer = document.getElementById('boardContainer');
const pathCanvas = document.getElementById('pathCanvas');
const ctx = pathCanvas.getContext('2d');
const timerDiv = document.getElementById('timer');
const modeSelect = document.getElementById('mode');
const resetBtn = document.getElementById('resetBtn');

modeSelect.addEventListener('change', ()=> { gameMode = modeSelect.value; updateDisplay(); });
resetBtn.addEventListener('click', initGame);

function seed(dateStr){
  let hash = 0;
  for(let i=0;i<dateStr.length;i++) hash = (hash*31 + dateStr.charCodeAt(i)) & 0xffffffff;
  return hash;
}

function randomSeeded(seed) {
  let x = Math.sin(seed++)*10000;
  return x - Math.floor(x);
}

function generateBoard() {
  const today = new Date();
  const seedVal = seed(today.toISOString().slice(0,10));
  const day = today.getDay();
  const difficulty = day + 1;

  const numSegments = 2 + difficulty;
  const numColors = Math.min(colors.length, 3 + Math.floor(difficulty/2));
  if(difficulty >= 6) N = 6; else N = 5;

  path = [];
  for(let r=0;r<N;r++){
    if(r%2===0){ for(let c=0;c<N;c++) path.push({r,c}); }
    else { for(let c=N-1;c>=0;c--) path.push({r,c}); }
  }

  parColorChanges = numSegments-1;

  const segmentLengths = [];
  let baseLen = Math.floor(path.length / numSegments);
  let remainder = path.length % numSegments;
  for(let i=0;i<numSegments;i++){
    segmentLengths.push(baseLen + (remainder>0 ? 1 : 0));
    remainder--;
  }

  let boardColors = [];
  let segIndex = 0;
  let colorIndex = Math.floor(randomSeeded(seedVal)*numColors);
  let countInSegment = 0;
  for(let i=0;i<path.length;i++){
    if(countInSegment===segmentLengths[segIndex]){
      segIndex++;
      countInSegment=0;
      let newColor;
      do { newColor = Math.floor(randomSeeded(seedVal+i)*numColors); } while(newColor===colorIndex);
      colorIndex=newColor;
    }
    boardColors.push(colorIndex);
    countInSegment++;
  }

  board = Array(N).fill(0).map(()=>Array(N).fill(0));
  for(let i=0;i<path.length;i++){
    const {r,c} = path[i];
    board[r][c] = boardColors[i];
  }
}

function initGame() {
  visited = new Set();
  colorChanges = 0;
  timer = 0;
  activeColor = null;
  lastCell = null;
  clearInterval(intervalId);
  intervalId = null;
  const oldBtn = document.getElementById('showSolutionBtn');
  if(oldBtn) oldBtn.remove();
  solutionButtonCreated = false;
  path = [];
  ctx.clearRect(0,0,pathCanvas.width,pathCanvas.height);
  generateBoard();
  drawBoard();
  updateDisplay();
}

function drawBoard(){
  boardDiv.style.gridTemplateColumns = `repeat(${N},${tileSize}px)`;
  boardDiv.style.width = `${N*tileSize}px`;
  boardDiv.style.height = `${N*tileSize}px`;
  pathCanvas.width = N*tileSize;
  pathCanvas.height = N*tileSize;
  boardDiv.innerHTML = '';
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.style.backgroundColor = colors[board[r][c]];
      tile.dataset.r = r;
      tile.dataset.c = c;
      tile.addEventListener('pointerdown', handleTileClick);
      tile.addEventListener('pointerover', handleTileHover);
      boardDiv.appendChild(tile);
    }
  }
}

function handleTileClick(e){
  const r = parseInt(e.target.dataset.r);
  const c = parseInt(e.target.dataset.c);
  const cell = {r,c};
  if(visited.size===0){
    path.push(cell);
    visited.add(`${r}_${c}`);
    activeColor = board[r][c];
    lastCell = cell;
    startTimerIfNeeded();
    drawPath();
    return;
  }
  extendPath(cell);
  drawPath();
  checkCompletion();
  updateDisplay();
}

function handleTileHover(e){
  if(e.buttons!==1) return;
  handleTileClick(e);
}

function extendPath(cell){
  if(!lastCell) return;
  const tileColor = board[cell.r][cell.c];
  if(tileColor !== activeColor){ activeColor = tileColor; colorChanges++; }
  if(isAdjacent(lastCell,cell) && !visited.has(`${cell.r}_${cell.c}`)){
    visited.add(`${cell.r}_${cell.c}`);
    path.push(cell);
    lastCell = cell;
  }
}

function isAdjacent(a,b){
  const dr = Math.abs(a.r-b.r);
  const dc = Math.abs(a.c-b.c);
  return (dr+dc===1);
}

function drawPath(){
  ctx.clearRect(0,0,pathCanvas.width,pathCanvas.height);
  if(path.length<2) return;
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 6;
  ctx.lineCap = 'round';
  ctx.beginPath();
  for(let i=0;i<path.length;i++){
    const {r,c} = path[i];
    const x = c*tileSize + tileSize/2;
    const y = r*tileSize + tileSize/2;
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();
}

function updateDisplay(){
  if(gameMode==='color') timerDiv.innerText = `Color Changes: ${colorChanges} | Time: ${timer.toFixed(1)}s | Par: ${parColorChanges}`;
  else timerDiv.innerText = `Time: ${timer.toFixed(1)}s | Color Changes: ${colorChanges} | Par: ${parColorChanges}`;
}

function startTimerIfNeeded(){
  if(intervalId) return;
  intervalId = setInterval(()=>{ timer+=0.1; updateDisplay(); },100);
}

function checkCompletion(){
  if(visited.size === N*N){
    clearInterval(intervalId);
    if(!solutionButtonCreated){
      let showBtn = document.createElement('button');
      showBtn.innerText = 'Show Solution';
      showBtn.id = 'showSolutionBtn';
      document.body.appendChild(showBtn);
      showBtn.addEventListener('click', ()=>{
        revealSolution();
        showBtn.disabled = true;
      });
      solutionButtonCreated = true;
    }
    alert(`ðŸŽ‰ Puzzle Complete!
Color Changes: ${colorChanges}
Time: ${timer.toFixed(1)}s`);
  }
}

function revealSolution(){
  path = path.slice(); // redraw full path
  drawPath();
  setTimeout(()=>{alert(`Minimal color changes needed: ${parColorChanges}`);}, 100);
}

initGame();
</script>
</body>
</html>
